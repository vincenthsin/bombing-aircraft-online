name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

env:
  NODE_VERSION: '18'
  BACKEND_DIR: './backend'
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/bombing-aircraft-backend

jobs:
  # Test job - runs tests and linting
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'backend/package-lock.json'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci

    - name: Start backend server
      run: |
        cd backend
        npm start &
        echo $! > server.pid

    - name: Wait for server to be ready
      run: |
        cd backend
        timeout 60 bash -c 'until curl -f http://localhost:3000/health; do sleep 1; done'
      shell: bash

    - name: Run backend tests
      run: |
        cd backend
        npm test

    - name: Stop backend server
      run: |
        cd backend
        if [ -f server.pid ]; then
          kill $(cat server.pid) || true
          rm server.pid
        fi
      if: always()

    - name: Check code formatting (optional)
      run: |
        cd backend
        # Add ESLint or Prettier checks here if you have them configured
        echo "Code formatting check passed"

  # Build job - builds the application
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'backend/package-lock.json'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci --production

    - name: Create production build
      run: |
        # Copy frontend files to backend for unified deployment
        mkdir -p backend/public
        cp -r frontend/public/* backend/public/

    - name: Upload backend build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: backend-build-artifacts
        path: |
          backend/
          !backend/node_modules/
          !backend/test-*.js
          !backend/simulator.js

    - name: Prepare frontend build artifacts
      run: |
        # Create a frontend build directory with all necessary files
        mkdir -p frontend-build
        cp -r frontend/public/* frontend-build/
        cp frontend/vercel.json frontend-build/
        # List files for debugging
        echo "Frontend build contents:"
        ls -la frontend-build/
        echo "Frontend build prepared successfully"

    - name: Upload frontend build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build-artifacts
        path: frontend-build/

  # Deploy Backend to staging using Docker and Render API
  deploy-backend:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && github.event_name == 'push'
    environment: staging
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha,prefix={{branch}}-,format=short
          type=ref,event=branch

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.backend
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Trigger Render Deployment
      id: trigger-deploy
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      run: |
        echo "Deploying to Render..."
        RESPONSE=$(curl -s -X POST \
          "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/deploys" \
          -H "Authorization: Bearer ${RENDER_API_KEY}" \
          -H "Content-Type: application/json" \
          -d '{"clearCache": "do_not_clear"}')
        
        DEPLOY_ID=$(echo $RESPONSE | jq -r '.id // empty')
        if [ -z "$DEPLOY_ID" ]; then
          echo "Failed to trigger deployment. Response: $RESPONSE"
          exit 1
        fi
        echo "DEPLOY_ID=$DEPLOY_ID" >> $GITHUB_ENV

    - name: Wait for Render deployment to complete
      env:
        RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
        RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      run: |
        echo "Waiting for deployment to complete..."
        MAX_WAIT=600
        ELAPSED=0
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          STATUS_RESPONSE=$(curl -s \
            "https://api.render.com/v1/services/${RENDER_SERVICE_ID}/deploys/${DEPLOY_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}")
          STATUS=$(echo $STATUS_RESPONSE | jq -r '.status // empty')
          echo "Deployment status: $STATUS (${ELAPSED}s elapsed)"
          if [ "$STATUS" = "live" ]; then
            echo "Deployment completed successfully!"
            exit 0
          elif [ "$STATUS" = "build_failed" ] || [ "$STATUS" = "deploy_failed" ] || [ "$STATUS" = "canceled" ]; then
            echo "Deployment failed with status: $STATUS"
            exit 1
          fi
          sleep 15
          ELAPSED=$((ELAPSED + 15))
        done
        echo "Deployment timed out"
        exit 1

  # Deploy Frontend to staging
  deploy-frontend:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && github.event_name == 'push'
    environment: staging
    outputs:
      frontend-url: ${{ steps.deploy-frontend.outputs.FRONTEND_URL }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download frontend build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-artifacts
        path: ./frontend-build

    - name: Deploy Frontend to Vercel
      id: deploy-frontend
      run: |
        echo "Deploying frontend to Vercel..."
        npm install -g vercel
        cd frontend-build
        DEPLOY_OUTPUT=$(vercel --token ${{ secrets.VERCEL_TOKEN }} --yes)
        FRONTEND_URL=$(echo "$DEPLOY_OUTPUT" | grep -o 'https://[^[:space:]]*' | head -1)
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "Frontend deployed to: $FRONTEND_URL"

  # Deploy Frontend to GitHub Pages as secondary frontend
  deploy-gh-pages:
    needs: build
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main') && github.event_name == 'push'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      contents: read
      pages: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v5
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: 'frontend/public'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # deploy-production:
  #   needs: build
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
  #   environment: production

  #   steps:
  #   - name: Download build artifacts
  #     uses: actions/download-artifact@v4
  #     with:
  #       name: build-artifacts
  #       path: ./build

  #   - name: Deploy to Railway (Production)
  #     if: env.RAILWAY_TOKEN_PRODUCTION != ''
  #     run: |
  #       npm install -g @railway/cli
  #       railway login --token ${{ secrets.RAILWAY_TOKEN_PRODUCTION }}

  #       cd build
  #       railway deploy --project ${{ secrets.RAILWAY_PROJECT_ID_PRODUCTION }}

  #   - name: Deploy to Render (Production)
  #     if: env.RENDER_DEPLOY_HOOK_PRODUCTION != ''
  #     run: |
  #       curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK_PRODUCTION }}

  #   - name: Deploy to Heroku (Production)
  #     if: env.HEROKU_API_KEY_PRODUCTION != ''
  #     uses: akhileshns/heroku-deploy@v3.12.14
  #     with:
  #       heroku_api_key: ${{ secrets.HEROKU_API_KEY_PRODUCTION }}
  #       heroku_app_name: ${{ secrets.HEROKU_APP_NAME_PRODUCTION }}
  #       heroku_email: ${{ secrets.HEROKU_EMAIL }}
  #       appdir: "build"

  #   - name: Deploy Frontend to Vercel
  #     if: env.VERCEL_TOKEN != ''
  #     run: |
  #       npm install -g vercel
  #       cd frontend/public
  #       vercel --prod --token ${{ secrets.VERCEL_TOKEN }} --yes

  #   - name: Deploy Frontend to Netlify
  #     if: env.NETLIFY_AUTH_TOKEN != ''
  #     run: |
  #       npm install -g netlify-cli
  #       cd frontend/public
  #       netlify deploy --prod --dir . --auth ${{ secrets.NETLIFY_AUTH_TOKEN }} --site ${{ secrets.NETLIFY_SITE_ID }}

  # Health check and integration testing
  health-check:
    needs: [deploy-backend, deploy-frontend, deploy-gh-pages]
    runs-on: ubuntu-latest
    if: always() && needs.deploy-backend.result == 'success' && needs.deploy-frontend.result == 'success' && needs.deploy-gh-pages.result == 'success'

    steps:
    - name: Health check for staging
      run: |
        # Wait for deployment to be ready
        sleep 30

        # Get URLs from outputs
        FRONTEND_URL="${{ needs.deploy-frontend.outputs.frontend-url }}"

        echo "Backend URL: ${{vars.BACKEND_URL}}"
        echo "Frontend URL: $FRONTEND_URL"

        # Validate URLs are not empty
      

        if [ -z "$FRONTEND_URL" ]; then
          echo "Error: Frontend URL is empty. Deployment may have failed to capture the URL."
          exit 1
        fi

        # Check if the backend is responding
        if curl -f "${{vars.BACKEND_URL}}/health"; then
          echo "Backend health check passed!"
        else
          echo "Backend health check failed! URL: ${{vars.BACKEND_URL}}/health"
          exit 1
        fi

        # Check if the frontend is responding
        if curl -f "${FRONTEND_URL}"; then
          echo "Frontend health check passed!"
        else
          echo "Frontend health check failed! URL: ${FRONTEND_URL}"
          exit 1
        fi

        echo "Staging deployment successful!"
        echo "Frontend URL: $FRONTEND_URL"


    # - name: Health check for production
    #   if: needs.deploy-production.result == 'success'
    #   run: |
    #     # Wait for deployment to be ready
    #     sleep 30

    #     # Check if the app is responding
    #     if curl -f ${{ secrets.PRODUCTION_URL }}/health; then
    #       echo "Production deployment successful!"
    #     else
    #       echo "Production health check failed!"
    #       exit 1
    #     fi

  # Notify on deployment status
  notify:
    needs: [health-check]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Send Discord notification
      if: always()
      uses: Ilshidur/action-discord@master
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
      with:
        args: 'Deployment status for ${{ github.repository }}: ${{ job.status }}. Commit: ${{ github.sha }}'