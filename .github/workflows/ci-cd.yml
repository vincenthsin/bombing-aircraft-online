name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop, 31-create-cicd-pipeline ]
  pull_request:
    branches: [ main, master, develop ]

env:
  NODE_VERSION: '18'
  BACKEND_DIR: './backend'
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
  # Test job - runs tests and linting
  test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'backend/package-lock.json'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci

    - name: Start backend server
      run: |
        cd backend
        npm start &
        echo $! > server.pid

    - name: Wait for server to be ready
      run: |
        cd backend
        timeout 60 bash -c 'until curl -f http://localhost:3000/health; do sleep 1; done'
      shell: bash

    - name: Run backend tests
      run: |
        cd backend
        npm test

    - name: Stop backend server
      run: |
        cd backend
        if [ -f server.pid ]; then
          kill $(cat server.pid) || true
          rm server.pid
        fi
      if: always()

    - name: Check code formatting (optional)
      run: |
        cd backend
        # Add ESLint or Prettier checks here if you have them configured
        echo "Code formatting check passed"

  # Build job - builds the application
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/31-create-cicd-pipeline'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: 'backend/package-lock.json'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci --production

    - name: Create production build
      run: |
        # Copy frontend files to backend for unified deployment
        mkdir -p backend/public
        cp -r frontend/public/* backend/public/

    - name: Upload backend build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: backend-build-artifacts
        path: |
          backend/
          !backend/node_modules/
          !backend/test-*.js
          !backend/simulator.js

    - name: Prepare frontend build artifacts
      run: |
        # Create a frontend build directory with all necessary files
        mkdir -p frontend-build
        cp -r frontend/public/* frontend-build/
        cp frontend/vercel.json frontend-build/
        # List files for debugging
        echo "Frontend build contents:"
        ls -la frontend-build/
        echo "Frontend build prepared successfully"

    - name: Upload frontend build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build-artifacts
        path: frontend-build/

  # Deploy to staging
  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/31-create-cicd-pipeline' && github.event_name == 'push'
    environment: staging
    outputs:
      backend-url: ${{ steps.deploy-backend.outputs.BACKEND_URL }}
      frontend-url: ${{ steps.deploy-frontend.outputs.FRONTEND_URL }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download backend build artifacts
      uses: actions/download-artifact@v4
      with:
        name: backend-build-artifacts
        path: ./backend-build

    - name: Download frontend build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build-artifacts
        path: ./frontend-build

    - name: Deploy Backend to Railway (Staging)
      if: env.RAILWAY_TOKEN_STAGING != ''
      run: |
        npm install -g @railway/cli
        railway login --token ${{ secrets.RAILWAY_TOKEN_STAGING }}

        cd backend-build
        railway deploy --project ${{ secrets.RAILWAY_PROJECT_ID_STAGING }}

    - name: Deploy Backend to Render (Staging)
      if: env.RENDER_DEPLOY_HOOK_STAGING != ''
      run: |
        curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK_STAGING }}

    - name: Deploy Backend to Heroku (Staging)
      if: env.HEROKU_API_KEY_STAGING != ''
      uses: akhileshns/heroku-deploy@v3.12.14
      with:
        heroku_api_key: ${{ secrets.HEROKU_API_KEY_STAGING }}
        heroku_app_name: ${{ secrets.HEROKU_APP_NAME_STAGING }}
        heroku_email: ${{ secrets.HEROKU_EMAIL }}
        appdir: "backend-build"

    - name: Deploy Backend to Vercel (Staging)
      id: deploy-backend
      run: |
        npm install -g vercel
        cd backend-build
        # Capture the deployment URL from vercel output
        DEPLOY_OUTPUT=$(vercel --token ${{ secrets.VERCEL_TOKEN }} --yes)
        BACKEND_URL=$(echo "$DEPLOY_OUTPUT" | grep -o 'https://[^[:space:]]*' | head -1)
        echo "BACKEND_URL=$BACKEND_URL" >> $GITHUB_OUTPUT
        echo "Staging backend deployed to: $BACKEND_URL"

    - name: Update Frontend Config with Backend URL
      run: |
        # Debug: Check current directory and available files
        pwd
        ls -la
        ls -la scripts/ || echo "scripts directory not found"
        ls -la frontend-build/ || echo "frontend-build directory not found"

        # Copy the update script to frontend-build directory and run it
        if [ -f "scripts/update-frontend-config.js" ]; then
          cp scripts/update-frontend-config.js frontend-build/
          cd frontend-build
          # Update vercel.json with the actual backend URL using the script
          node update-frontend-config.js ${{ steps.deploy-backend.outputs.BACKEND_URL }}
        else
          echo "Script not found, falling back to sed command"
          cd frontend-build
          sed -i "s|https://your-backend-domain.vercel.app|${{ steps.deploy-backend.outputs.BACKEND_URL }}|g" vercel.json
          echo "Updated frontend config with backend URL: ${{ steps.deploy-backend.outputs.BACKEND_URL }}"
        fi

    - name: Deploy Frontend to Vercel (Staging)
      id: deploy-frontend
      run: |
        npm install -g vercel
        cd frontend-build
        echo "Current directory contents:"
        pwd && ls -la
        echo "Deploying to Vercel..."
        # Capture the deployment URL from vercel output
        DEPLOY_OUTPUT=$(vercel --token ${{ secrets.VERCEL_TOKEN }} --yes)
        echo "Vercel output: $DEPLOY_OUTPUT"
        FRONTEND_URL=$(echo "$DEPLOY_OUTPUT" | grep -o 'https://[^[:space:]]*' | head -1)
        echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "Staging frontend deployed to: $FRONTEND_URL"

  # Deploy to production - COMMENTED OUT
  # deploy-production:
  #   needs: build
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
  #   environment: production

  #   steps:
  #   - name: Download build artifacts
  #     uses: actions/download-artifact@v4
  #     with:
  #       name: build-artifacts
  #       path: ./build

  #   - name: Deploy to Railway (Production)
  #     if: env.RAILWAY_TOKEN_PRODUCTION != ''
  #     run: |
  #       npm install -g @railway/cli
  #       railway login --token ${{ secrets.RAILWAY_TOKEN_PRODUCTION }}

  #       cd build
  #       railway deploy --project ${{ secrets.RAILWAY_PROJECT_ID_PRODUCTION }}

  #   - name: Deploy to Render (Production)
  #     if: env.RENDER_DEPLOY_HOOK_PRODUCTION != ''
  #     run: |
  #       curl -X POST ${{ secrets.RENDER_DEPLOY_HOOK_PRODUCTION }}

  #   - name: Deploy to Heroku (Production)
  #     if: env.HEROKU_API_KEY_PRODUCTION != ''
  #     uses: akhileshns/heroku-deploy@v3.12.14
  #     with:
  #       heroku_api_key: ${{ secrets.HEROKU_API_KEY_PRODUCTION }}
  #       heroku_app_name: ${{ secrets.HEROKU_APP_NAME_PRODUCTION }}
  #       heroku_email: ${{ secrets.HEROKU_EMAIL }}
  #       appdir: "build"

  #   - name: Deploy Frontend to Vercel
  #     if: env.VERCEL_TOKEN != ''
  #     run: |
  #       npm install -g vercel
  #       cd frontend/public
  #       vercel --prod --token ${{ secrets.VERCEL_TOKEN }} --yes

  #   - name: Deploy Frontend to Netlify
  #     if: env.NETLIFY_AUTH_TOKEN != ''
  #     run: |
  #       npm install -g netlify-cli
  #       cd frontend/public
  #       netlify deploy --prod --dir . --auth ${{ secrets.NETLIFY_AUTH_TOKEN }} --site ${{ secrets.NETLIFY_SITE_ID }}

  # Health check and integration testing
  health-check:
    needs: [deploy-staging]  # deploy-production commented out
    runs-on: ubuntu-latest
    if: always() && needs.deploy-staging.result == 'success'

    steps:
    - name: Health check for staging
      if: needs.deploy-staging.result == 'success'
      run: |
        # Wait for deployment to be ready
        sleep 30

        # Check if the backend is responding
        if vercel curl -f "${{ needs.deploy-staging.outputs.backend-url }}/health"; then
          echo "Backend health check passed!"
        else
          echo "Backend health check failed!"
          exit 1
        fi

        # Check if the frontend is responding
        if vercel curl -f "${{ needs.deploy-staging.outputs.frontend-url }}"; then
          echo "Frontend health check passed!"
        else
          echo "Frontend health check failed!"
          exit 1
        fi

        echo "Staging deployment successful!"
        echo "Frontend URL: ${{ needs.deploy-staging.outputs.frontend-url }}"
        echo "Backend URL: ${{ needs.deploy-staging.outputs.backend-url }}"

    # - name: Health check for production
    #   if: needs.deploy-production.result == 'success'
    #   run: |
    #     # Wait for deployment to be ready
    #     sleep 30

    #     # Check if the app is responding
    #     if curl -f ${{ secrets.PRODUCTION_URL }}/health; then
    #       echo "Production deployment successful!"
    #     else
    #       echo "Production health check failed!"
    #       exit 1
    #     fi

  # Notify on deployment status
  notify:
    needs: [health-check]
    runs-on: ubuntu-latest
    if: always()

    steps:
    - name: Send Slack notification
      if: env.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}